package squidpony.squidai;

import squidpony.squidgrid.Radius;

import java.awt.Point;
import java.util.LinkedHashMap;

/**
 * Static utilities for use in AOE and anything else that might need HashMaps of Point keys to Double values.
 * Created by Tommy Ettinger on 7/13/2015.
 */
public class AreaUtils {
    /**
     * This takes a 2D boolean array and returns a HashMap of Point keys to Double values, but will only use the value
     * 1.0, and only for positions in map that have as their boolean element true.
     * @param map width by height, commonly generated by FOV methods
     * @return a HashMap of Point keys to Double values, but the only value used is 1.0
     */
    public static LinkedHashMap<Point, Double> arrayToHashMap(boolean[][] map)
    {
        LinkedHashMap<Point, Double> ret = new LinkedHashMap<>();
        for(int i = 0; i < map.length; i++)
        {
            for(int j = 0; j < map[i].length; j++)
            {
                if(map[i][j])
                    ret.put(new Point(i, j), 1.0);
            }
        }
        return ret;
    }

    /**
     * This takes a 2D double array called map and returns a HashMap of Point keys to Double values, and will have a key
     * for every position in map that is greater than 0.0, with values equal to those in map.
     * @param map width by height, commonly generated by FOV methods
     * @return a HashMap of Point keys to Double values, with values all greater than 0.0
     */
    public static LinkedHashMap<Point, Double> arrayToHashMap(double[][] map)
    {
        LinkedHashMap<Point, Double> ret = new LinkedHashMap<>();
        for(int i = 0; i < map.length; i++)
        {
            for(int j = 0; j < map[i].length; j++)
            {
                if(map[i][j] > 0.0)
                    ret.put(new Point(i, j), map[i][j]);
            }
        }
        return ret;
    }

    /**
     * This takes a 2D double array and returns a HashMap of Point keys to Double values, but will only use the value
     * 1.0, and only does this if the passed double[][] has a value at that position that is greater than cutoff.
     * For example, a cutoff of 0.3 will make all elements in the 2D array that are 0.3 or less be ignored and not put
     * into the HashMap, but all elements that are greater than 0.3 will be placed in as 1.0.
     * @param map width by height, commonly generated by FOV methods
     * @param cutoff any elements greater than this will be 1.0 in the return, anything else will be ignored
     * @return a HashMap of Point keys to Double values, but the only value used is 1.0
     */
    public static LinkedHashMap<Point, Double> arrayToHashMap(double[][] map, double cutoff)
    {
        LinkedHashMap<Point, Double> ret = new LinkedHashMap<>();
        for(int i = 0; i < map.length; i++)
        {
            for(int j = 0; j < map[i].length; j++)
            {
                if(map[i][j] > cutoff)
                    ret.put(new Point(i, j), 1.0);
            }
        }
        return ret;
    }

    /**
     * This takes a DijkstraMap that has already completed a scan() and returns a HashMap of Point keys to Double
     * values, and will have a key for every position that was reached in the DijkstraMap, with 1.0 as the only value.
     * @param map a double[][] returned by a DijkstraMap running its scan()
     * @return a HashMap of Point keys to Double values, with values of 1.0 only
     */
    public static LinkedHashMap<Point, Double> dijkstraToHashMap(double[][] map)
    {
        LinkedHashMap<Point, Double> ret = new LinkedHashMap<>();
        for(int i = 0; i < map.length; i++)
        {
            for(int j = 0; j < map[i].length; j++)
            {
                if(map[i][j] < DijkstraMap.WALL)
                    ret.put(new Point(i, j), 1.0);
            }
        }
        return ret;
    }

    /**
     * Checks that the given end Point can be targeted from the given origin Point given the directional targeting
     * rules specified by limit. If any of the arguments are null, returns true (it assumes that any limits are not
     * valid and don't restrict anything). The following Radius enum values for limit have the following meanings:
     *
     * <ul>
     *     <li>Radius.CIRCLE, Radius.SPHERE, Radius.SQUARE or RADIUS.CUBE will only consider Points to be valid targets
     *     if they are along a straight line with an angle that is a multiple of 45 degrees, relative to the positive x
     *     axis. Essentially, this limits the points to those a queen could move to in chess.</li>
     *     <li>Radius.DIAMOND or Radius.OCTAHEDRON will cause the AOE to only consider Points to be valid targets if
     *     they are along a straight line with an angle that is a multiple of 90 degrees, relative to the positive x
     *     axis. Essentially, this limits the points to those a rook could move to in chess.</li>
     * </ul>
     *
     * @param limit DIAMOND or OCTAHEDRON for rook-like, other enum values for queen-like, null for unrestricted
     * @param origin where the user is
     * @param end where the point we want to verify is
     * @return true if the point is a valid target or if the limits are invalid (non-restricting), false otherwise
     */
    public static boolean verifyLimit(Radius limit, Point origin, Point end)
    {
        if (limit != null && origin != null && end != null) {
            switch (limit) {
                case SQUARE:
                case CUBE:
                case CIRCLE:
                case SPHERE:
                    if(Math.abs(end.x - origin.x) == Math.abs(end.y - origin.y))
                    {
                        return true;
                    }
                case DIAMOND:
                case OCTAHEDRON:
                    if(end.x == origin.x || end.y == origin.y)
                    {
                        return true;
                    }
                    break;
            }
            return false;
        }
        else
            return true;
    }
}
